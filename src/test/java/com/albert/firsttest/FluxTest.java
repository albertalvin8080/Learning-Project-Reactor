package com.albert.firsttest;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;
import reactor.core.publisher.BaseSubscriber;
import reactor.core.publisher.ConnectableFlux;
import reactor.core.publisher.Flux;
import reactor.test.StepVerifier;

import java.time.Duration;
import java.util.List;

/*
 * Note to self: you used the word 'flux' (uncased) meaning 'stream of data/events' in the comments.
 * */
@Slf4j
public class FluxTest {
    private final List<String> names = List.of("Heide", "Old Golem", "Heide Knight");

    @Test
    void Flux_FromIterable() {
        final Flux<String> flux = Flux.fromIterable(names).log();

        StepVerifier.create(flux)
                .expectNext(names.toArray(new String[0]))
                .verifyComplete();
    }

    @Test
    void Flux_FromRange() {
        final Flux<Integer> flux = Flux.range(1, 10)
                .log()
                // handler() is preferred to map() when the code may throw an exception
                .handle((i, sink) -> {
                    if (i > 3) {
                        sink.error(new IndexOutOfBoundsException("Index above 3"));
                        return;
                    }
                    sink.next(i);
                });

        flux.subscribe(
                i -> log.info("i: {}", i),
                Throwable::printStackTrace,
                () -> log.info("COMPLETED"),
                s -> s.request(4)
        );

        log.info("-------------------------------------------------------{}", System.lineSeparator());

        StepVerifier.create(flux)
                .expectNext(1, 2, 3)
                .verifyError(IndexOutOfBoundsException.class);
    }

    @Test
    void Flux_BackpressureWithCustomSubscriber() {
        final Flux<Integer> flux = Flux.range(1, 10).log();

        flux.subscribe(new Subscriber<Integer>() {
            private final int requestCount = 3;
            private int requestIndex = 0;
            private Subscription subscription;

            @Override
            public void onSubscribe(Subscription s) {
                this.subscription = s;
                subscription.request(requestCount);
            }

            @Override
            public void onNext(Integer integer) {
                log.info("i: {}", integer);
                if (++requestIndex == requestCount) {
                    requestIndex = 0;
                    subscription.request(requestCount);
                }
            }

            @Override
            public void onError(Throwable t) {

            }

            @Override
            public void onComplete() {
                log.info("CUSTOM SUBSCRIBER COMPLETED");
            }
        });
    }

    @Test
    void Flux_BackpressureWithBaseSubscriber() {
        final Flux<Integer> flux = Flux.range(1, 10).log();

        flux.subscribe(new BaseSubscriber<Integer>() {
            private final int requestCount = 2;
            private int requestIndex = 0;

            @Override
            protected void hookOnSubscribe(Subscription subscription) {
                request(requestCount);
            }

            @Override
            protected void hookOnNext(Integer value) {
                if (++requestIndex >= requestCount) {
                    requestIndex = 0;
                    request(requestCount);
                }
            }

            @Override
            protected void hookOnComplete() {
                log.info("COMPLETED");
            }
        });
    }

    @Test
    void Flux_LimitRate() {
        final Flux<Integer> flux = Flux.range(1, 5)
                .log()
                .limitRate(3); // Needs to come after log(). Sets the limit of each request(n) to limitRate(n)

        StepVerifier.create(flux)
                .expectNext(1, 2, 3, 4, 5)
                .verifyComplete();
    }

    @Test
    void Flux_Interval() throws InterruptedException {
        final Flux<Long> flux = Flux.interval(Duration.ofMillis(100))
                .take(20); // limits the events generated by the interval()

        flux.subscribe(l -> log.info("{}", l));

        // This is necessary because the interval() executes in a separate thread from the main.
        // When the main thread ends, it automatically stops, unless it's explicitly stated to sleep (or wait).
        Thread.sleep(3000);
    }

    @Test
    void Flux_Interval_VirtualTime() {
        // The Flux<> MUST be created inside withVirtualTime(), otherwise the
        // method won't know if the Scheduler was created appropriately
        StepVerifier.withVirtualTime(this::createFluxInterval)
                .expectSubscription()
                .expectNoEvent(Duration.ofHours(24)) // makes sure there are no events before the stipulated time.
                .thenAwait(Duration.ofDays(2))
                .expectNext(0L)
                .expectNext(1L)
                .thenCancel() // if not present, the interval() would produce events indefinitely.
                .verify();

        // another way of using thenAwait()
        StepVerifier.withVirtualTime(this::createFluxInterval)
                .expectSubscription()
                .expectNoEvent(Duration.ofDays(1))
                .thenAwait(Duration.ofDays(1))
                .expectNext(0L)
                .thenAwait(Duration.ofDays(1))
                .expectNext(1L)
                .thenCancel()
                .verify();
    }

    private Flux<Long> createFluxInterval() {
        return Flux.interval(Duration.ofDays(1)).log();
    }

    @Test
    void ConnectableFlux() throws InterruptedException {
        final ConnectableFlux<Integer> connectableFlux = Flux.range(1, 5)
//                .log()
                .delayElements(Duration.ofMillis(100))
                .publish();

        connectableFlux.connect();

        // This sleep() waits until some elements are lost due to the nature of Hot Observables.
        Thread.sleep(200);
        connectableFlux.subscribe(i -> log.info("i1: {}", i));

        // Same here.
        Thread.sleep(150);
        connectableFlux.subscribe(i -> log.info("i2: {}", i));

        // Makes the main thread wait for the parallel threads.
        Thread.sleep(3000);
    }

    @Test
    void ConnectableFlux_StepVerifier() throws InterruptedException {
        final ConnectableFlux<Integer> connectableFlux = Flux.range(1, 10)
                .log()
                .limitRate(3)
                .delayElements(Duration.ofMillis(100))
                .publish();

        StepVerifier.create(connectableFlux)
                .then(connectableFlux::connect)
                .thenConsumeWhile(i -> i <= 5) // basically ignores the first 5 elements
                .expectNext(6, 7, 8, 9, 10)
                .verifyComplete();
    }

    @Test
    void ConnectableFlux_AutoConnect() {
        final Flux<Integer> autoConnect = Flux.range(1, 5)
                .log()
                .limitRate(2)
                .publish()
                .autoConnect(2); // defines the minimum number of subscribers before the Publisher begins to emit events.

        StepVerifier.create(autoConnect)
                .then(autoConnect::subscribe) // if not present, the Publisher will make the main thread wait until there are enough subscribers.
                .expectNext(1, 2, 3, 4, 5)
                .verifyComplete();
    }
}
